    # --- Derivative block (filtered) ---
    if Td > 0.0:
        alpha = Tf / (Tf + dt)
        d_filtered = alpha * filtered_prev + (1.0 - alpha) * ((e - e_prev) / dt)
    else:
        d_filtered = 0.0

    # --- Integral update proposal ---
    if Ti > 0.0:
        integral_candidate = integral + e * dt
    else:
        integral_candidate = integral

    # Unscaled integrator
    I_term_unscaled = (1.0 / Ti) * integral if Ti > 0 else 0.0
    # scaled integrator
    I_term_scaled = Kp * I_term_unscaled
    # unsaturated control output
    u_unsat = Kp * (e + Td * d_filtered) + I_term_scaled

    # Unscaled integrator candidate
    I_term_candidate_unscaled = (1.0 / Ti) * integral_candidate if Ti > 0 else 0.0
    # scaled integrator candidate
    I_term_candidate_scaled = Kp * I_term_candidate_unscaled
    # unsaturated control output candidate
    u_unsat_candidate = Kp * (e + Td * d_filtered) + I_term_candidate_scaled

    # --- Anti-windup ---
    if anti_windup_method == AntiWindupInt.CONDITIONAL:

        # Allow integration only if it will not cause saturation on control output
        if (u_min < u_unsat_candidate < u_max) or \
                (u_unsat_candidate >= u_max and e < 0.0) or \
                (u_unsat_candidate <= u_min and e > 0.0):
            integral = integral_candidate
            u = u_unsat_candidate
        else:
            u = u_unsat
        u = min(max(u, u_min), u_max)

    elif anti_windup_method == AntiWindupInt.CLAMPING:

        # Allow integration only if it will not cause saturation inside integration
        if (u_min < I_term_scaled < u_max) or \
                (I_term_scaled >= u_max and e < 0.0) or \
                (I_term_scaled <= u_min and e > 0.0):
            integral = integral_candidate
            u = u_unsat_candidate
        else:
            u = u_unsat
        u = min(max(u, u_min), u_max)

    else:
        u = 0.0  # safety fallback

    return u, integral, d_filtered